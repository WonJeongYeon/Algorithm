<h1>백준 1181 - 단어 정렬</h1>

입력 횟수 N이 주어진다.
이후 N개의 단어가 주어진다.

단어는 길이가 짧은 단어부터, 길이가 같을 경우 사전순으로 정렬한다.

정렬 결과를 1줄씩 출력한다.

<b>큰 틀은 정렬 방법이다. 입력 시 길이를 비교하여 정렬하고, 길이가 같은 것은 o1.compareTo(o2)로 비교한다.</b>
```java
(o1, o2) -> {
            if (o1.length() == o2.length()) {
                return o1.compareTo(o2);
            }
            return o1.length()-o2.length();
        }
```

제출할 해답이 두 가지인 이유는, 자료구조 사용이 다르기 때문이다.

- PriorityQueue<String>을 사용하여 알아서 정렬되는 코드
- String[]을 사용하여 입력하고 Arrays.sort()를 사용해 정렬

두 방법 모두 성능은 비슷하다. 각각 332ms, 324ms를 기록했고 메모리는
23232kb, 25796kb였다.

<b>두 가지중 정답이 정해진 것은 아닌 것 같다.</b>

통과는 하지만 시간이 4배 가량 불어났던 해답도 있었는데, 이는 PriorityQueue를 사용하되,
중복 제거를 입력 시 contains()를 사용했기 때문이다.
이 때 시간은 1660ms를 기록했다.

PriorityQueue를 먼저 사용했던 이유는 Arrays.sort()가 Collections.sort()보다 다소 비효율적이라고
알고 있었고, 중복 제거를 contains()를 사용하려다보니 배열 사용이 꺼려졌기 때문이다.
덕분에 효율적인 코드를 작성하려다 4배 비효율적인 코드를 작성한 셈이다.

어떤 자료구조를 사용하던지 어차피 정렬이 되어있는 상태이므로 출력할 때 사용하는 반복문에서
한 단계 이전의 인덱스와 비교해서 같지 않을 때만 출력하도록 하면 중복이 제거되므로 contains()를 사용할 필요가 없는 문제였다.



